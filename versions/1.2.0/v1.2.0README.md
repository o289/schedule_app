# version 1.2.0

## 機能追加

**1. 登録済み日時リストの中で、時刻を編集できるようにする**

目的（Background / WHY）:

- 日によって開始・終了が異なる予定に対応するため
- UX 向上と入力時間短縮が目的
- バックエンド変更なし、フロントのみで完結

要件（Requirements / WHAT）:

![モーダル画像](dates-modal-item.jpg)

- モーダル内で日付ごとの start/end を個別編集可能にする
- start/end を TimePicker に置き換える
- ピッカー操作時点で state に反映
- モーダル閉鎖時は送信せず、親画面の「登録」ボタンで backend に反映
- 未編集の要素は元の値を保持
- 編集された要素のみ start/end を更新して送信する

データ構造（Data Model）:

```js
type DateItem = {
  date: string, // YYYY-MM-DD
  start: string, // HH:mm
  end: string, // HH:mm
};
```

UX 仕様（UI Behavior）:

- start/end 表示部分を TimePicker に差し替える
- ピッカーは start と end それぞれに配置
- 初期値は date.start / date.end
- UI レイアウト変更は最小限（p タグ →Picker の差し替えのみ）
- モーダル閉鎖時は state を保持
- アニメーションは付けない

フロー（Flow）:

1. モーダルを開く
2. 編集したい日時の start/end をピッカーで変更
3. モーダルを閉じる（この時点では送信なし）
4. 親画面で「登録」ボタン押下
5. 編集された項目だけ start/end が置換され backend に送信される

想定外挙動（Risk）:

- 複数項目の start/end が意図せず全て更新される
- アイテム削除に伴うインデックスずれの可能性

影響範囲（Scope）:

- DatesModal.jsx（このファイルで完結予定）
- 表示形式を start_date → start に扱うため既存コードの一部修正あり

効果（Value）:

- ユーザーが柔軟に予定入力できるようになる
- 入力作業の短縮と UX の向上

実装:

- モーダル内部では UI 用に `_local_id` を付与（React key 用）
- 保存時には `_local_id` を strip し、API 用データに変換する

補足説明（Implementation Detail）:

- `_local_id` は UI 専用の識別子として、モーダルを開いた時点で内部データに付与されます。React における `key` の安定化が目的であり、バックエンドの ID 管理には一切関与しません。
- モーダル内での編集はすべてこの内部データ（internalDates）上で行われ、親コンポーネントが保持する実データには影響を与えません。
- モーダルを閉じる際、内部状態は破棄されます。保存（onSave）時のみ、`_local_id` を取り除いた API 用の純粋な `{ start_date, end_date }` 形式に変換して親に返すため、バックエンドのスキーマと衝突することはありません。
- これにより、UI 側では安定したキー管理と柔軟な編集が可能になりつつ、バックエンドには完全にクリーンなデータのみが送信される構造になります。

**2. CURD の際の自前アラート**

目的:

ユーザーがデータの作成・編集・削除に成功したか失敗したか、失敗したならなぜかをアナウンスするため

変更:

共通のコンポーネントを作成し、app.tsx にコンポーネントを配置する。またこれらのの API にコンポーネントに表示する文字列を生成するロジックを追加する

効果:

UX 向上

## 機能改善

## リファクタリング

1. 共通時刻ピッカーの導入

目的:

- **機能追加 1**を行うための下準備
- 複数箇所で使用するため

要件:

- バックエンド、DB ロジックには一切の影響はない、与えてはいけない
- 共通で使用する時刻ピッカーの新規作成
- 使用箇所はモーダル画面とスケジュール登録・編集フォームの３ケース

- 引数は value,min,max
- min, max は 1 呼び出しにつき、どちらかの値しか再代入できないようにする(min={value + 1}であれば max は null でないといけない)
- 両方の入力を許可するとレンジが極端に狭まる
- min は end 側で使用、max は start 側の制御で使用

- start は end より遅い時刻を選べないようにし、end は start より、早い時刻を選べないようにする
- 範囲は"00:00"-"23:30"
- 間隔は 30 分ごと

- min は value より１つ後の値、max は value より１つ前の値
- \*min, max チェックと更新は picker 内部で行う
- \*補正処理もピッカー内部で行う予定

\*変更ファイルが 3 つ以上になる可能性がある場合は親コンポーネントで行う

引数:

```jsx
timePicker({ value, min, max });

// セットする値
value[string]["HH:mm"];

// 選べる最小
// endの値を制御するのに使用
// 例: startが"12:00"であれば、minは"12:30"になるようにする
// この引数はnullを許可
min[string]["HH:mm"];

// 選べる最大
// startの値を制御するのに使用
// 例: endが"12:00"であれば、maxは"11:30"になるようにする
// この引数はnullを許可
max[string]["HH:mm"];

// 返却する値
[string]["HH:mm"];
```

フロー（Flow）:

ピッカー本体

1. 開く
2. 値を選択
3. 値を反映
4. 更新された値が start であれば、min, end であれば、max の値を更新
5. もう片方の値が未入力の場合、min, max の値(value 前後の"30 分刻み")を自動補正入力
6. 選択不能範囲は非表示

start, end どちらのピッカーを動かしても問題はない仕様
min, max 計算ロジック

1. 値(value)が変更される
2. min, max の props の null チェック
3. null でない方の値(min, max どちらか)を更新
4. ピッカーの日付生成ロジックを更新
5. 反映

コード(イメージ):

```jsx
// 30分刻みの候補生成
const generateTimeOptions = () => {
  const times = [];
  for (let h = 0; h < 24; h++) {
    for (let m = 0; m < 60; m += 30) {
      const hour = String(h).padStart(2, "0");
      const minute = String(m).padStart(2, "0");
      times.push(`${hour}:${minute}`);
    }
  }
  return times;
};

const timeOptions = generateTimeOptions();

/**
 * min/max は「value の前後30分」を取得した値
 * ※ value, min, max は props なので直接代入は NG。
 *   計算値は内部 state に保持する必要がある。
 */
const getAdjacentTimes = (value) => {
  if (!value) return { next: null, prev: null };
  const idx = timeOptions.indexOf(value);
  if (idx === -1) return { next: null, prev: null };

  return {
    next: timeOptions[idx + 1] ?? null, // min に相当
    prev: timeOptions[idx - 1] ?? null, // max に相当
  };
};

const [internalMin, setInternalMin] = useState(null);
const [internalMax, setInternalMax] = useState(null);

useEffect(() => {
  const { next, prev } = getAdjacentTimes(value);
  setInternalMin(next);
  setInternalMax(prev);
}, [value]);

// オプション生成ロジック（選択可能な範囲だけを表示）
{
  timeOptions.map((time) =>
    // min/max がなければ全て表示
    (!internalMin && !internalMax) ||
    // min〜max の範囲内だけ表示
    (internalMax &&
      internalMin &&
      time >= internalMax &&
      time <= internalMin) ? (
      <option key={time} value={time}>
        {time}
      </option>
    ) : null
  );
}
```

想定外挙動（Risk）:

- 呼び出し側コンポーネントで min/max の制御ミス
- 既存 UI との整合性（value が string → dayjs 等）
- 共通化によって複数画面の挙動に一括影響する可能性
- ピッカー内部のフォーマット仕様変更によるレガシー化

影響範囲:

- DatesModal.jsx -> 既存の"{formatDateTime(date.start_date || "-", "datetime")}"から、日にちを上に配置し、時刻を編集できる newPicker に置き換える
- MultiDateCalender.jsx -> TimeRangePicker でを直接生成しているものを newPicker 製に置き換える。このコンポーネントのプロップスは一切変更しない。またこのコンポーネント以上の親への影響は一切与えない
- NewPicker.jsx -> 新規追加、ファイル名は仮 このファイルでピッカーの役割を完結させる

## 実装順
